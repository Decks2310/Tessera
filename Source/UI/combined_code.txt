================================================================================
// File: CustomLookAndFeel.cpp
================================================================================

// File: UI/CustomLookAndFeel.cpp
#include "CustomLookAndFeel.h"

CustomLookAndFeel::CustomLookAndFeel()
{
    setColour(juce::ResizableWindow::backgroundColourId, juce::Colour(0xff2d2d2d));
    setColour(juce::ComboBox::outlineColourId, juce::Colours::transparentBlack);
    setColour(juce::TextButton::buttonColourId, juce::Colour(0xff3a3a3a));
    setColour(juce::ComboBox::buttonColourId, juce::Colours::transparentBlack);

    moduleBgColour = juce::Colour(0xff3a3a3a);
    emptySlotColour = juce::Colour(0xff2d2d2d);
    accentColour = juce::Colour(0xfff0c419);
    textColour = juce::Colours::white;
}

void CustomLookAndFeel::drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height, float sliderPos,
    const float rotaryStartAngle, const float rotaryEndAngle, juce::Slider& slider)
{
    auto bounds = juce::Rectangle<float>((float)x, (float)y, (float)width, (float)height).reduced(10);
    auto radius = juce::jmin(bounds.getWidth(), bounds.getHeight()) / 2.0f;
    auto toAngle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
    auto lineW = 2.0f;
    auto arcRadius = radius - lineW;

    g.setColour(moduleBgColour.brighter(0.2f));
    juce::Path backgroundArc;
    backgroundArc.addCentredArc(bounds.getCentreX(), bounds.getCentreY(), arcRadius, arcRadius, 0.0f, rotaryStartAngle, rotaryEndAngle, true);
    g.strokePath(backgroundArc, juce::PathStrokeType(lineW, juce::PathStrokeType::curved, juce::PathStrokeType::butt));
    if (slider.isEnabled())
    {
        g.setColour(accentColour);
        juce::Path valueArc;
        valueArc.addCentredArc(bounds.getCentreX(), bounds.getCentreY(), arcRadius, arcRadius, 0.0f, rotaryStartAngle, toAngle, true);
        g.strokePath(valueArc, juce::PathStrokeType(lineW, juce::PathStrokeType::curved, juce::PathStrokeType::butt));
    }

    juce::Point<float> thumbPoint = bounds.getCentre().getPointOnCircumference(radius * 0.7f, toAngle);
    g.setColour(textColour);
    g.drawLine({ bounds.getCentre(), thumbPoint }, 2.0f);
}

// UPDATED: Overhauled for a modern, clean look, including Bipolar visualization, corrected geometry, and thumb outline.
void CustomLookAndFeel::drawLinearSlider(juce::Graphics& g, int x, int y, int width, int height,
    float sliderPos, float minSliderPos, float maxSliderPos, const juce::Slider::SliderStyle style, juce::Slider& slider)
{
    // FIXED: Address C4100 warnings by ignoring unused parameters.
    juce::ignoreUnused(minSliderPos);
    juce::ignoreUnused(maxSliderPos);

    // Check for standard linear styles (Horizontal/Vertical)
    if (style == juce::Slider::LinearHorizontal || style == juce::Slider::LinearVertical)
    {
        auto bounds = juce::Rectangle<int>(x, y, width, height).toFloat();

        // 1. Determine Thumb Size FIRST (Crucial for track calculation)
        // FIX: Use a consistent thumb size (16.0f) for both vertical and horizontal sliders
        // to match the appearance of the Master Mix slider.
        // auto thumbDiameter = (style == juce::Slider::LinearVertical) ? 12.0f : 16.0f; // OLD
        auto thumbDiameter = 16.0f; // NEW
        auto thumbRadius = thumbDiameter / 2.0f;

        // 2. Define the track appearance
        // FIX: Increased thickness to match the Master Mix slider visual weight.
        // float trackThickness = 4.0f; // OLD
        float trackThickness = 8.0f; // NEW
        float cornerRadius = trackThickness / 2.0f;

        // 3. Calculate Track Bounds (THE FIX)
        // We reduce the bounds by the thumb radius at the ends so the track visualization aligns with sliderPos.
        juce::Rectangle<float> trackBounds;

        if (style == juce::Slider::LinearHorizontal)
        {
            // Horizontal: Reduce the width by the thumb radius on both sides
            trackBounds = bounds.reduced(thumbRadius, 0)
                .withHeight(trackThickness)
                .withCentre(bounds.getCentre());
        }
        else
        {
            // Vertical: Reduce the height by the thumb radius on both top and bottom
            trackBounds = bounds.reduced(0, thumbRadius)
                .withWidth(trackThickness)
                .withCentre(bounds.getCentre());
        }


        // 4. Draw the background track
        g.setColour(moduleBgColour.brighter(0.3f)); // Slightly brighter than module background
        g.fillRoundedRectangle(trackBounds, cornerRadius);

        // 5. Draw the value track (the filled portion)
        juce::Rectangle<float> valueTrackBounds = trackBounds;

        // Use effectiveSliderPos clamped to the visual track bounds for drawing the fill
        float effectiveSliderPos;

        if (style == juce::Slider::LinearHorizontal)
        {
            effectiveSliderPos = juce::jlimit(trackBounds.getX(), trackBounds.getRight(), sliderPos);
            // Standard horizontal fill (Master Mix)
            valueTrackBounds = valueTrackBounds.withWidth(effectiveSliderPos - trackBounds.getX());
        }
        else // Vertical
        {
            effectiveSliderPos = juce::jlimit(trackBounds.getY(), trackBounds.getBottom(), sliderPos);

            // Bipolar visualization for vertical sliders (Input/Output Gain)
            // This logic is kept as it correctly visualizes gain from the center 0dB point.
            if (slider.getMinimum() < 0.0 && slider.getMaximum() > 0.0)
            {
                // Calculate the zero position based on OUR track geometry.
                const float proportion = (float)slider.valueToProportionOfLength(0.0);
                // Note: In JUCE vertical sliders (default), proportion 1.0 is at the TOP, 0.0 is at the BOTTOM.
                float zeroPos = trackBounds.getBottom() - trackBounds.getHeight() * proportion;

                // Clamp zeroPos within track bounds just in case of precision issues
                zeroPos = juce::jlimit(trackBounds.getY(), trackBounds.getBottom(), zeroPos);

                if (slider.getValue() >= 0.0)
                {
                    // Positive value: Fill from zeroPos UPWARDS to effectiveSliderPos
                    valueTrackBounds = trackBounds.withTop(effectiveSliderPos).withHeight(zeroPos - effectiveSliderPos);
                }
                else
                {
                    // Negative value: Fill from zeroPos DOWNWARDS to effectiveSliderPos
                    valueTrackBounds = trackBounds.withTop(zeroPos).withHeight(effectiveSliderPos - zeroPos);
                }
            }
            else
            {
                // Standard visualization (fill from bottom up)
                valueTrackBounds = valueTrackBounds.withTop(effectiveSliderPos).withHeight(trackBounds.getBottom() - effectiveSliderPos);
            }
        }

        g.setColour(accentColour);
        g.fillRoundedRectangle(valueTrackBounds, cornerRadius);

        // 6. Draw the Thumb
        juce::Rectangle<float> thumbBounds(thumbDiameter, thumbDiameter);

        // The input sliderPos is the correct center point for the thumb.
        if (style == juce::Slider::LinearHorizontal)
        {
            thumbBounds.setCentre({ sliderPos, trackBounds.getCentreY() });
        }
        else
        {
            thumbBounds.setCentre({ trackBounds.getCentreX(), sliderPos });
        }

        g.setColour(accentColour);
        g.fillEllipse(thumbBounds);

        // FIX: Add an outline to the thumb (Matches Picture 2).
        g.setColour(emptySlotColour); // Use the darkest color for outline contrast
        g.drawEllipse(thumbBounds.reduced(1.0f), 1.5f);
    }
    // Keep the existing logic for Bar style if needed
    // FIX: Replace deprecated slider.isBar()
    // else if (slider.isBar()) // OLD
    else if (style == juce::Slider::LinearBar || style == juce::Slider::LinearBarVertical) // NEW
    {
        // (Existing bar implementation remains)
        g.setColour(moduleBgColour.brighter(0.2f));
        g.fillRect(slider.getLocalBounds().toFloat());

        g.setColour(accentColour);
        const float value = (float)slider.valueToProportionOfLength(slider.getValue());
        if (value > 0)
            g.fillRect(slider.getLocalBounds().withWidth((int)((float)slider.getWidth() * value)).toFloat());
    }
    else
    {
        // (Fallback implementation remains the same)
        auto bounds = juce::Rectangle<int>(x, y, width, height).toFloat().reduced(0.5f);
        g.setColour(moduleBgColour.brighter(0.2f));
        g.fillRoundedRectangle(bounds, 5.0f);

        auto thumbWidth = 10.0f;
        auto thumbBounds = juce::Rectangle<float>(thumbWidth, (float)height).withCentre(bounds.getCentre());
        thumbBounds.setX(sliderPos - (thumbWidth / 2.0f));

        g.setColour(accentColour);
        g.fillRoundedRectangle(thumbBounds, 5.0f);
    }
}

void CustomLookAndFeel::drawToggleButton(juce::Graphics& g, juce::ToggleButton& button,
    bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown)
{
    juce::ignoreUnused(shouldDrawButtonAsHighlighted, shouldDrawButtonAsDown);
    auto bounds = button.getLocalBounds().toFloat().reduced(2.0f);

    g.setColour(button.getToggleState() ? accentColour : moduleBgColour.brighter(0.2f));
    g.fillRoundedRectangle(bounds, 5.0f);

    g.setColour(textColour);
    g.drawFittedText(button.getButtonText(), bounds.toNearestInt(), juce::Justification::centred, 1);
}

void CustomLookAndFeel::drawComboBox(juce::Graphics& g, int width, int height, bool,
    int, int, int, int, juce::ComboBox& box)
{
    juce::ignoreUnused(box);
    auto cornerSize = 5.0f;
    juce::Rectangle<int> boxBounds(0, 0, width, height);

    g.setColour(moduleBgColour.brighter(0.2f));
    g.fillRoundedRectangle(boxBounds.toFloat(), cornerSize);
}

void CustomLookAndFeel::positionComboBoxText(juce::ComboBox& box, juce::Label& label)
{
    label.setBounds(box.getLocalBounds().reduced(5, 0));
    label.setFont(juce::FontOptions((float)box.getHeight() * 0.7f));
    label.setColour(juce::Label::textColourId, textColour);
    label.setJustificationType(juce::Justification::centredLeft);
}

juce::Font CustomLookAndFeel::getLabelFont(juce::Label&)
{
    return juce::Font(juce::FontOptions().withHeight(14.0f));
}

void CustomLookAndFeel::drawTextBoxedText(juce::Graphics& g, const juce::String& text, juce::Rectangle<int> bounds)
{
    g.setColour(moduleBgColour.brighter(0.2f));
    g.fillRoundedRectangle(bounds.toFloat(), 4.0f);

    g.setColour(textColour.withAlpha(0.5f));
    g.drawRect(bounds.toFloat(), 1.0f);

    g.setColour(textColour);
    g.drawFittedText(text, bounds, juce::Justification::centred, 1);
}

================================================================================
// File: CustomLookAndFeel.h
================================================================================

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class CustomLookAndFeel : public juce::LookAndFeel_V4
{
public:
    CustomLookAndFeel();
    ~CustomLookAndFeel() override = default;

    void drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height, float sliderPos,
        const float rotaryStartAngle, const float rotaryEndAngle, juce::Slider& slider) override;

    void drawLinearSlider(juce::Graphics& g, int x, int y, int width, int height,
        float sliderPos, float minSliderPos, float maxSliderPos,
        const juce::Slider::SliderStyle, juce::Slider& slider) override;

    void drawToggleButton(juce::Graphics& g, juce::ToggleButton& button,
        bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override;

    void drawComboBox(juce::Graphics& g, int width, int height, bool,
        int, int, int, int, juce::ComboBox& box) override;

    // Add the declaration for our new function
    void positionComboBoxText(juce::ComboBox& box, juce::Label& label) override;

    juce::Font getLabelFont(juce::Label& label) override;

    // Helper function for drawing text labels for parameters
    void drawTextBoxedText(juce::Graphics& g, const juce::String& text, juce::Rectangle<int> bounds);

    juce::Colour moduleBgColour;
    juce::Colour emptySlotColour;
    juce::Colour accentColour;
    juce::Colour textColour;
};

================================================================================
// File: EmbeddedSVGs.h
================================================================================

﻿#pragma once

namespace EmbeddedSVGs
{
    // Use Raw String Literals R"SVG(...)SVG" for embedding.
    // The base color is #000000 (black), which allows for dynamic recoloring in the UI.

    // 1. Distortion
    static const char* distortionData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Distortion</title>
  <path d="M4 32 C 10 20, 18 20, 24 32 C 30 44, 32 44, 36 32 L 40 18 L 44 46 L 48 22 L 52 42 L 56 30 L 60 34"
        fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
)SVG";

    // 2. Filter
    static const char* filterData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Filter</title>
  <path d="M 4 20 H 30 C 40 20, 44 24, 48 32 C 52 40, 56 48, 60 52"
        fill="none" stroke="#000000" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
)SVG";

    // 3. Modulation
    static const char* modulationData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Modulation</title>
  <path d="M 4 32 C 16 16, 24 16, 32 32 C 40 48, 48 48, 60 32"
        fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round"/>
  <path d="M 4 32 C 16 48, 24 48, 32 32 C 40 16, 48 16, 60 32"
        fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" opacity="0.6"/>
</svg>
)SVG";

    // 4. Delay
    static const char* delayData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Delay</title>
  <ellipse cx="14" cy="32" rx="10" ry="16" fill="#000000" opacity="1"/>
  <ellipse cx="34" cy="32" rx="8" ry="14" fill="#000000" opacity="0.6"/>
  <ellipse cx="50" cy="32" rx="6" ry="12" fill="#000000" opacity="0.3"/>
</svg>
)SVG";

    // 5. Reverb
    static const char* reverbData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Reverb</title>
  <path d="M 24 50 C 36 44, 36 20, 24 14" fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" opacity="1"/>
  <path d="M 34 56 C 48 48, 48 16, 34 8" fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" opacity="0.7"/>
  <path d="M 44 62 C 60 52, 60 12, 44 2" fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" opacity="0.4"/>
</svg>
)SVG";

    // 6. Compressor
    static const char* compressorData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Compressor</title>
  <path d="M4 18 H 24 L 28 26 H 36 L 40 18 H 60" fill="none" stroke="#000000" stroke-width="4" stroke-linejoin="round"/>
  <path d="M4 46 H 24 L 28 38 H 36 L 40 46 H 60" fill="none" stroke="#000000" stroke-width="4" stroke-linejoin="round"/>
  <path d="M 32 10 L 32 16 M 28 13 L 32 17 L 36 13" fill="none" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M 32 54 L 32 48 M 28 51 L 32 47 L 36 51" fill="none" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
)SVG";

    // 7. ChromaTape (NEW)
    static const char* chromaTapeData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>ChromaTape</title>
  <circle cx="32" cy="32" r="28" fill="none" stroke="#000000" stroke-width="4"/>
  <circle cx="32" cy="32" r="8" fill="#000000"/>
  <rect x="12" y="20" width="40" height="6" fill="#000000" opacity="0.4"/>
  <rect x="12" y="30" width="40" height="6" fill="#000000" opacity="0.7"/>
  <rect x="12" y="40" width="40" height="6" fill="#000000" opacity="1.0"/>
</svg>
)SVG";

    // 8. BBD Cloud (NEW)
    static const char* bbdCloudData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>BBD Cloud</title>
  <path d="M30 40 C 35 30, 45 30, 50 40 C 55 45, 60 40, 60 35 C 60 25, 50 20, 45 25 C 40 20, 35 25, 30 30 Z"
        fill="#000000" opacity="0.9" transform="rotate(10 45 35)"/>
  <path d="M 10 32 H 20" stroke="#000000" stroke-width="3" stroke-linecap="round"/>
  <path d="M 15 24 H 25" stroke="#000000" stroke-width="3" stroke-linecap="round" opacity="0.6"/>
  <path d="M 10 40 H 20" stroke="#000000" stroke-width="3" stroke-linecap="round" opacity="0.3"/>
</svg>
)SVG";

    // 9. FractureTube (Placeholder) (NEW)
    static const char* fractureTubeData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>FractureTube</title>
  <path d="M 20 54 L 20 30 C 20 18, 32 10, 32 10 C 32 10, 44 18, 44 30 L 44 54" fill="none" stroke="#000000" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M 24 40 H 40 M 24 30 H 40" stroke="#000000" stroke-width="2" stroke-linecap="round"/>
  <path d="M 32 15 L 36 20 L 32 25 L 28 20 Z" fill="#000000" opacity="0.8"/>
  <path d="M 16 58 H 48" stroke="#000000" stroke-width="4" stroke-linecap="round"/>
</svg>
)SVG";

    // 10. MorphoComp (Placeholder) (NEW)
    static const char* morphoCompData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>MorphoComp</title>
  <path d="M 4 32 L 20 32 L 32 20 L 44 44 L 60 32" fill="none" stroke="#000000" stroke-width="5" stroke-linecap="round" stroke-linejoin="round" opacity="1"/>
  <path d="M 4 32 C 16 20, 24 20, 32 32 C 40 44, 48 44, 60 32" fill="none" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" opacity="0.5" stroke-dasharray="5 5"/>
</svg>
)SVG";

    // ✅ NEW: Dice Icon for Randomization
    static const char* diceData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Random</title>
  <rect x="10" y="10" width="44" height="44" rx="8" fill="none" stroke="#000000" stroke-width="4"/>
  <circle cx="22" cy="22" r="4" fill="#000000"/>
  <circle cx="42" cy="22" r="4" fill="#000000"/>
  <circle cx="32" cy="32" r="4" fill="#000000"/>
  <circle cx="22" cy="42" r="4" fill="#000000"/>
  <circle cx="42" cy="42" r="4" fill="#000000"/>
</svg>
)SVG";

    // 11. Spectral Animator (NEW)
    static const char* spectralAnimatorData = R"SVG(
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="64" height="64">
  <title>Spectral Animator</title>
  <path d="M 8 56 V 8 L 56 8 V 56 Z" fill="none" stroke="#000000" stroke-width="4" stroke-linejoin="round"/>
  <path d="M 16 48 V 24 L 24 40 L 32 16 L 40 44 L 48 20 V 48" fill="none" stroke="#000000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
)SVG";
}

================================================================================
// File: ModuleHeader.cpp
================================================================================

#include "ModuleHeader.h"
#include "CustomLookAndFeel.h"

ModuleHeader::ModuleHeader()
{
    addAndMakeVisible(title);
    title.setJustificationType(juce::Justification::centred);
    title.setFont(juce::FontOptions(16.0f));

    addAndMakeVisible(optionsButton);
    optionsButton.onClick = [this] { if (onMenuClicked) onMenuClicked(); };

    addAndMakeVisible(deleteButton);
    deleteButton.onClick = [this] { if (onDeleteClicked) onDeleteClicked(); };
}

void ModuleHeader::paint(juce::Graphics& g)
{
    if (isDragHovering)
    {
        CustomLookAndFeel laf;
        g.setColour(laf.accentColour);
        g.drawRect(getLocalBounds().toFloat(), 2.0f);
    }
}

void ModuleHeader::mouseDrag(const juce::MouseEvent& event)
{
    juce::ignoreUnused(event);
    auto* dragContainer = juce::DragAndDropContainer::findParentDragContainerFor(this);
    if (dragContainer)
    {
        juce::var dragDescription = getSlotIndex();
        juce::Image dragImage(juce::Image::PixelFormat::ARGB, 1, 1, true);

        // UPDATED: Pass the juce::Image directly.
        // dragContainer->startDragging(dragDescription, this, juce::ScaledImage(dragImage), false); // OLD
        dragContainer->startDragging(dragDescription, this, dragImage, false); // NEW
    }
}

bool ModuleHeader::isInterestedInDragSource(const SourceDetails&)
{
    return true;
}

void ModuleHeader::itemDropped(const SourceDetails& dragSourceDetails)
{
    int sourceSlotIndex = dragSourceDetails.description;
    int targetSlotIndex = getSlotIndex();
    if (onSlotMoved)
        onSlotMoved(sourceSlotIndex, targetSlotIndex);

    isDragHovering = false;
    repaint();
}

void ModuleHeader::itemDragEnter(const SourceDetails&)
{
    isDragHovering = true;
    repaint();
}

void ModuleHeader::itemDragExit(const SourceDetails&)
{
    isDragHovering = false;
    repaint();
}

void ModuleHeader::resized()
{
    auto bounds = getLocalBounds();
    deleteButton.setBounds(bounds.removeFromLeft(30).reduced(5));
    optionsButton.setBounds(bounds.removeFromRight(30).reduced(5));
    title.setBounds(bounds);
}

================================================================================
// File: ModuleHeader.h
================================================================================

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>

class ModuleHeader : public juce::Component,
    public juce::DragAndDropTarget
{
public:
    std::function<void()> onMenuClicked;
    std::function<void()> onDeleteClicked;
    std::function<int()> getSlotIndex;
    std::function<void(int, int)> onSlotMoved;

    juce::Label title;
    juce::TextButton optionsButton{ "..." };
    juce::TextButton deleteButton{ "-" };

    ModuleHeader();

    void paint(juce::Graphics& g) override;
    void mouseDrag(const juce::MouseEvent& event) override;

    // Drag and Drop Target overrides
    bool isInterestedInDragSource(const SourceDetails& dragSourceDetails) override;
    void itemDropped(const SourceDetails& dragSourceDetails) override;
    void itemDragEnter(const SourceDetails& dragSourceDetails) override;
    void itemDragExit(const SourceDetails& dragSourceDetails) override;

    void resized() override;
private:
    bool isDragHovering = false;
    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ModuleHeader)
};

================================================================================
// File: ModuleSelectionGrid.cpp
================================================================================

#include "ModuleSelectionGrid.h"
#include "EmbeddedSVGs.h" // Include the new SVG data

//==============================================================================
// ModuleGridButton Implementation
//==============================================================================

ModuleGridButton::ModuleGridButton(const juce::String& text, const char* svgData)
    : juce::Button(text)
{
    // Load the SVG data from the embedded string.
    if (svgData != nullptr)
    {
        // FIXED: Simply construct the juce::String from the const char* as it is null-terminated.
        // juce::String svgString = juce::String::createStringFromData(svgData, (int)strlen(svgData)); // OLD
        juce::String svgString(svgData); // NEW

        // Use parseXML (free function) to get the XmlElement
        if (auto svgElement = juce::parseXML(svgString))
        {
            // Create the Drawable from the XmlElement
            svgImage = juce::Drawable::createFromSVG(*svgElement);
        }
    }
    // Ensure the button doesn't toggle state, it's just for selection
    setClickingTogglesState(false);
}

// CLEANED: Removed invisible characters (0xa0) that caused C3872 errors.
void ModuleGridButton::paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) {
    // FIX: Retrieve the active LookAndFeel and cast it to access custom colors.
    auto* lnf = dynamic_cast<CustomLookAndFeel*>(&getLookAndFeel());

    // Define Colors based on the active LAF, providing fallbacks if the cast fails.
    const juce::Colour defaultBackground = (lnf != nullptr) ? lnf->moduleBgColour : juce::Colour(0xff3a3a3a);
    const juce::Colour highlightColour = (lnf != nullptr) ? lnf->accentColour : juce::Colour(0xfff0c419);
    const juce::Colour defaultIconColour = (lnf != nullptr) ? lnf->textColour : juce::Colours::white;
    const juce::Colour highlightIconColour = (lnf != nullptr) ? lnf->emptySlotColour : juce::Colour(0xff2d2d2d);

    bool isInteracting = shouldDrawButtonAsHighlighted || shouldDrawButtonAsDown;
    juce::Colour effectiveBackground;
    juce::Colour effectiveIconColour;

    // Set colors based on state
    if (isInteracting)
    {
        effectiveBackground = highlightColour;
        effectiveIconColour = highlightIconColour;
    }
    else
    {
        effectiveBackground = defaultBackground;
        effectiveIconColour = defaultIconColour;
    }

    // 1. Draw Background
    g.setColour(effectiveBackground);
    g.fillRoundedRectangle(getLocalBounds().toFloat(), 5.0f);

    // 2. Define Areas for Icon and Text
    auto bounds = getLocalBounds().reduced(5);
    auto textArea = bounds.removeFromBottom(20);
    auto iconArea = bounds.reduced(5); // Padding for the icon

    // 3. Draw Icon
    if (svgImage != nullptr)
    {
        // CRITICAL: Correctly handle dynamic recoloring for persistent Drawables.

        // Step A: Replace the base color (black) with the effective color.
        svgImage->replaceColour(juce::Colours::black, effectiveIconColour);

        // Step B: Draw the SVG.
        svgImage->drawWithin(g, iconArea.toFloat(),
            juce::RectanglePlacement::centred, 1.0f);

        // Step C: Revert the color back to the base color (black) so it's ready for the next paint cycle.
        svgImage->replaceColour(effectiveIconColour, juce::Colours::black);
    }

    // 4. Draw Text
    g.setColour(effectiveIconColour);
    g.setFont(13.0f);
    g.drawText(getButtonText(), textArea, juce::Justification::centred);
}

//==============================================================================
// ModuleSelectionGrid Implementation
//==============================================================================

ModuleSelectionGrid::ModuleSelectionGrid(juce::StringArray choices)
{
    // Ensure the grid uses the custom LAF for background color
    setLookAndFeel(&lookAndFeel);

    for (int i = 0; i < choices.size(); ++i)
    {
        auto* button = new ModuleGridButton(choices[i], getSvgDataForChoice(i + 1));
        button->onClick = [this, i]
            {
                // Dismiss the CallOutBox when a selection is made
                if (auto* callout = findParentComponentOfClass<juce::CallOutBox>())
                    callout->dismiss();

                if (onModuleSelected)
                    onModuleSelected(i + 1);
            };
        buttons.add(button);
        addAndMakeVisible(button);
    }
}

ModuleSelectionGrid::~ModuleSelectionGrid()
{
    setLookAndFeel(nullptr);
}

void ModuleSelectionGrid::paint(juce::Graphics& g) {
    // Set the background color for the entire grid area (the popup background)
    // Use the darkest color (emptySlotColour or ResizableWindow::backgroundColourId)
    g.fillAll(lookAndFeel.emptySlotColour);
}

// UPDATED: 4 columns x 3 rows layout for 10 modules
void ModuleSelectionGrid::resized() {
    juce::Grid grid;

    using Track = juce::Grid::TrackInfo;
    using Fr = juce::Grid::Fr;

    // UPDATED: 4 columns x 3 rows layout.
    grid.templateColumns = { Track(Fr(1)), Track(Fr(1)), Track(Fr(1)), Track(Fr(1)) };
    grid.templateRows = { Track(Fr(1)), Track(Fr(1)), Track(Fr(1)) };

    // Add spacing
    grid.setGap(juce::Grid::Px(8));

    for (auto* b : buttons)
        grid.items.add(juce::GridItem(b));

    // Perform layout with padding
    grid.performLayout(getLocalBounds().reduced(10));
}

// UPDATED: Aligned to 12 modules, including Physical Resonator.
const char* ModuleSelectionGrid::getSvgDataForChoice(int choice) {
    switch (choice)
    {
    case 1: return EmbeddedSVGs::distortionData;
    case 2: return EmbeddedSVGs::filterData;
    case 3: return EmbeddedSVGs::modulationData;
    case 4: return EmbeddedSVGs::delayData;
    case 5: return EmbeddedSVGs::reverbData;
    case 6: return EmbeddedSVGs::compressorData;
    case 7: return EmbeddedSVGs::chromaTapeData;
    case 8: return EmbeddedSVGs::bbdCloudData;
    case 9: return EmbeddedSVGs::fractureTubeData;
    case 10: return EmbeddedSVGs::morphoCompData;
    case 11: return EmbeddedSVGs::spectralAnimatorData;
        // FIX: Added Case 12 for Physical Resonator. (Using Dice icon as placeholder)
    case 12: return EmbeddedSVGs::diceData;
    default: return nullptr;
    }
}

================================================================================
// File: ModuleSelectionGrid.h
================================================================================

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include "CustomLookAndFeel.h"

// Renamed from IconTextButton and updated for SVG rendering
class ModuleGridButton : public juce::Button
{
public:
    // Updated constructor to take SVG data (const char*)
    ModuleGridButton(const juce::String& text, const char* svgData);
    // Updated paintButton signature
    void paintButton(juce::Graphics& g, bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override;
private:
    // Use juce::Drawable for SVG
    std::unique_ptr<juce::Drawable> svgImage;
    // CustomLookAndFeel lookAndFeel; // <-- REMOVE THIS LINE
};

class ModuleSelectionGrid : public juce::Component
{
public:
    std::function<void(int)> onModuleSelected;

    ModuleSelectionGrid(juce::StringArray choices);
    ~ModuleSelectionGrid() override; // Added destructor

    // Added paint override for the grid background
    void paint(juce::Graphics& g) override;
    void resized() override;
private:
    // Helper function updated to return SVG data
    const char* getSvgDataForChoice(int choice);
    // Updated array type
    juce::OwnedArray<ModuleGridButton> buttons;
    CustomLookAndFeel lookAndFeel;
};

================================================================================
// File: ModuleSlot.cpp
================================================================================

﻿// File: UI/ModuleSlot.cpp
#include "ModuleSlot.h"
#include "ModuleHeader.h"
#include "ModuleSelectionGrid.h"
#include "SlotEditors.h"
// NEW: Explicitly include the new editor definition
#include "PhysicalResonatorSlotEditor.h"

ModuleSlot::ModuleSlot(juce::AudioProcessorValueTreeState& apvts, int slotIndex)
    : valueTreeState(apvts), index(slotIndex)
{
    setLookAndFeel(&lookAndFeel);
    slotChoiceParamId = "SLOT_" + juce::String(index + 1) + "_CHOICE";
    slotPrefix = "SLOT_" + juce::String(index + 1) + "_";

    header = std::make_unique<ModuleHeader>();
    addAndMakeVisible(*header);
    header->onMenuClicked = [this] { showModuleMenu(); };
    header->getSlotIndex = [this] { return index; };
    header->onDeleteClicked = [this]
        {
            auto* param = valueTreeState.getParameter(slotChoiceParamId);
            param->setValueNotifyingHost(0.0f);
        };
    header->onSlotMoved = [this](int sourceSlot, int targetSlot)
        {
            auto sourceParamId = "SLOT_" + juce::String(sourceSlot + 1) + "_CHOICE";
            auto targetParamId = "SLOT_" + juce::String(targetSlot + 1) + "_CHOICE";

            auto* sourceParam = valueTreeState.getParameter(sourceParamId);
            auto* targetParam = valueTreeState.getParameter(targetParamId);
            if (sourceParam && targetParam)
            {
                float sourceVal = sourceParam->getValue();
                float targetVal = targetParam->getValue();
                sourceParam->setValueNotifyingHost(targetVal);
                targetParam->setValueNotifyingHost(sourceVal);
            }
        };

    addAndMakeVisible(addModuleButton);
    addModuleButton.onClick = [this] { showModuleMenu(); };

    // === FIX: Initialize Synchronously ===
    // We must initialize the module content synchronously before adding the listener.
    if (auto* paramValue = valueTreeState.getRawParameterValue(slotChoiceParamId))
    {
        // Call createModule directly.
        createModule(static_cast<int>(paramValue->load()));
    }
    else
    {
        createModule(0); // Safety fallback
    }

    // Now register the listener for future changes.
    valueTreeState.addParameterListener(slotChoiceParamId, this);
}

ModuleSlot::~ModuleSlot()
{
    setLookAndFeel(nullptr);
    valueTreeState.removeParameterListener(slotChoiceParamId, this);
}

void ModuleSlot::paint(juce::Graphics& g) {
    auto bounds = getLocalBounds();
    g.setColour(lookAndFeel.moduleBgColour);
    g.fillRoundedRectangle(bounds.toFloat(), 8.0f);

    if (currentEditor == nullptr)
    {
        g.setColour(lookAndFeel.emptySlotColour);
        g.fillRoundedRectangle(bounds.toFloat(), 8.0f);
        g.setColour(lookAndFeel.emptySlotColour.brighter(0.1f));
        for (int i = -bounds.getHeight(); i < bounds.getWidth(); i += 15)
        {
            g.drawLine((float)i, (float)bounds.getBottom(), (float)i + (float)bounds.getHeight(), (float)bounds.getY(), 2.0f);
        }
    }
}

void ModuleSlot::resized() {
    auto bounds = getLocalBounds();
    header->setBounds(bounds.removeFromTop(30));
    if (currentEditor != nullptr)
        currentEditor->setBounds(bounds);
    else
        addModuleButton.setBounds(bounds.withSizeKeepingCentre(40, 40));
}

// === FIX: Implement Hybrid Sync/Async Update ===
void ModuleSlot::parameterChanged(const juce::String& parameterID, float newValue) {
    if (parameterID == slotChoiceParamId)
    {
        // If we are on the message thread (e.g., user clicked the UI), update immediately (synchronously).
        if (juce::MessageManager::getInstance()->isThisTheMessageThread())
        {
            createModule((int)newValue);
        }
        else
        {
            // If called from another thread (e.g., automation), schedule it safely (asynchronously).
            // Use SafePointer in case the slot is deleted (e.g., row removed) before the async call runs.
            juce::Component::SafePointer<ModuleSlot> safeThis(this);
            int choice = (int)newValue;

            juce::MessageManager::callAsync([safeThis, choice] {
                if (ModuleSlot* slot = safeThis.getComponent()) {
                    slot->createModule(choice);
                }
                });
        }
    }
}

void ModuleSlot::createModule(int choice) {
    currentEditor.reset();
    if (choice == 0)
    {
        header->setVisible(false);
        addAndMakeVisible(addModuleButton);
    }
    else
    {
        header->setVisible(true);
        currentEditor = createEditorForChoice(choice);
        if (currentEditor)
        {
            header->title.setText(getModuleName(choice), juce::dontSendNotification);
            removeChildComponent(&addModuleButton);
            addAndMakeVisible(*currentEditor);
            resized();
        }
    }
    repaint();
}

std::unique_ptr<juce::Component> ModuleSlot::createEditorForChoice(int choice) {
    switch (choice)
    {
    case 1: return std::make_unique<DistortionSlotEditor>(valueTreeState, slotPrefix);
    case 2: return std::make_unique<FilterSlotEditor>(valueTreeState, slotPrefix);
    case 3: return std::make_unique<ModulationSlotEditor>(valueTreeState, slotPrefix);
    case 4: return std::make_unique<AdvancedDelaySlotEditor>(valueTreeState, slotPrefix);
    case 5: return std::make_unique<ReverbSlotEditor>(valueTreeState, slotPrefix);
    case 6: return std::make_unique<AdvancedCompressorSlotEditor>(valueTreeState, slotPrefix);
    case 7: return std::make_unique<ChromaTapeSlotEditor>(valueTreeState, slotPrefix);
        // FIX: Corrected Mappings for 8-12, ensuring consistency.
    case 8: return std::make_unique<BBDCloudSlotEditor>(valueTreeState, slotPrefix);
    case 9: return std::make_unique<FractureTubeSlotEditor>(valueTreeState, slotPrefix);
    case 10: return std::make_unique<MorphoCompSlotEditor>(valueTreeState, slotPrefix);
    case 11: return std::make_unique<SpectralAnimatorSlotEditor>(valueTreeState, slotPrefix);
    case 12: return std::make_unique<PhysicalResonatorSlotEditor>(valueTreeState, slotPrefix);
    default: return nullptr;
    }
}
juce::String ModuleSlot::getModuleName(int choice) {
    switch (choice)
    {
    case 1: return "Distortion";
    case 2: return "Filter";
    case 3: return "Modulation";
    case 4: return "Delay";
    case 5: return "Reverb";
    case 6: return "Compressor";
    case 7: return "ChromaTape";
        // FIX: Corrected Mappings for 8-12
    case 8: return "BBD Cloud";
    case 9: return "FractureTube";
    case 10: return "MorphoComp";
    case 11: return "Spectral Animator";
    case 12: return "Physical Resonator";
    default: return "";
    }
}

void ModuleSlot::showModuleMenu() {
    auto* parameter = valueTreeState.getParameter(slotChoiceParamId);
    if (parameter == nullptr) return;

    auto choices = parameter->getAllValueStrings();
    choices.remove(0); // Remove "Empty"

    auto* grid = new ModuleSelectionGrid(choices);
    grid->setSize(420, 330);
    grid->onModuleSelected = [this, parameter](int choice)
        {
            parameter->setValueNotifyingHost(parameter->convertTo0to1(static_cast<float>(choice)));
        };

    juce::Rectangle<int> launchBounds;
    if (currentEditor == nullptr)
    {
        launchBounds = addModuleButton.getScreenBounds();
    }
    else
    {
        launchBounds = header->optionsButton.getScreenBounds();
    }

    juce::CallOutBox::launchAsynchronously(std::unique_ptr<juce::Component>(grid), launchBounds, nullptr);
}

================================================================================
// File: ModuleSlot.h
================================================================================

#pragma once
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_audio_processors/juce_audio_processors.h>
#include "CustomLookAndFeel.h"

class ModuleSelectionGrid;
class ModuleHeader;

class ModuleSlot : public juce::Component,
    private juce::AudioProcessorValueTreeState::Listener
{
public:
    ModuleSlot(juce::AudioProcessorValueTreeState& apvts, int slotIndex);
    ~ModuleSlot() override;

    void paint(juce::Graphics& g) override;
    void resized() override;
private:
    void parameterChanged(const juce::String& parameterID, float newValue) override;

    void createModule(int choice);
    // UPDATED: No longer returns an AudioProcessorEditor
    std::unique_ptr<juce::Component> createEditorForChoice(int choice);
    juce::String getModuleName(int choice);
    void showModuleMenu();

    juce::AudioProcessorValueTreeState& valueTreeState;
    int index;
    juce::String slotChoiceParamId;
    juce::String slotPrefix;

    CustomLookAndFeel lookAndFeel;

    std::unique_ptr<ModuleHeader> header;
    // UPDATED: No more temp processor, just a simple component for the editor
    std::unique_ptr<juce::Component> currentEditor;
    juce::TextButton addModuleButton{ "+" };

    juce::CallOutBox* callOut = nullptr;
};

================================================================================
// File: ParameterUIs.cpp
================================================================================

#include "ParameterUIs.h"
#include <JuceHeader.h> // Also needed here!

ParameterTextBox::ParameterTextBox(juce::AudioProcessorValueTreeState& apvtsRef, const juce::String& pId, const juce::String& lText)
    : apvts(apvtsRef), paramId(pId), labelText(lText)
{
    parameter = apvts.getParameter(paramId);
    apvts.addParameterListener(paramId, this);
    startTimerHz(30);
}

ParameterTextBox::~ParameterTextBox()
{
    apvts.removeParameterListener(paramId, this);
}

void ParameterTextBox::paint(juce::Graphics& g)
{
    auto bounds = getLocalBounds();
    auto labelBounds = bounds.removeFromLeft(bounds.getWidth() / 2);
    g.setColour(lookAndFeel.textColour);
    g.drawFittedText(labelText, labelBounds, juce::Justification::centredLeft, 1);

    if (parameter)
    {
        lookAndFeel.drawTextBoxedText(g, parameter->getCurrentValueAsText(), bounds);
    }
}

void ParameterTextBox::resized()
{
}

void ParameterTextBox::parameterChanged(const juce::String&, float)
{
}

================================================================================
// File: ParameterUIs.h
================================================================================

﻿// File: UI/ParameterUIs.h
#pragma once
#include <JuceHeader.h>
#include "CustomLookAndFeel.h"

// UPDATED: Inherit from juce::SettableTooltipClient
class RotaryKnobWithLabels : public juce::Component, public juce::SettableTooltipClient
{
public:
    RotaryKnobWithLabels(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramID, const juce::String& labelText)
    {
        slider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag);
        slider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);
        addAndMakeVisible(slider);

        attachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(apvts, paramID, slider);

        label.setText(labelText, juce::dontSendNotification);
        label.setJustificationType(juce::Justification::centred);
        label.setFont(juce::FontOptions(14.0f));
        addAndMakeVisible(label);
    }

    void resized() override
    {
        auto bounds = getLocalBounds();
        label.setBounds(bounds.removeFromBottom(20));
        slider.setBounds(bounds);
    }

    // FIX: Removed 'override' keyword (C3668)
    void setTooltip(const juce::String& newTooltip)
    {
        // FIX: Call the implementation provided by juce::SettableTooltipClient (C2039)
        juce::SettableTooltipClient::setTooltip(newTooltip);
        // Also ensure child components explicitly have the tooltip set
        slider.setTooltip(newTooltip);
        label.setTooltip(newTooltip);
    }
private:
    juce::Slider slider;
    juce::Label label;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> attachment;
};

// =============================================================================
// NEW: Helper class for ComboBoxes (Used in PhysicalResonator)
// =============================================================================
class ComboBoxWithLabel : public juce::Component, public juce::SettableTooltipClient
{
public:
    ComboBoxWithLabel(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramID, const juce::String& name)
    {
        addAndMakeVisible(comboBox);
        // Populate the combo box items from the parameter definition
        if (auto* param = apvts.getParameter(paramID))
        {
            comboBox.addItemList(param->getAllValueStrings(), 1);
        }

        label.setText(name, juce::dontSendNotification);
        label.setJustificationType(juce::Justification::centred);
        label.setFont(juce::FontOptions(14.0f));
        addAndMakeVisible(label);

        attachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramID, comboBox);
    }

    void resized() override
    {
        // Layout matching RotaryKnobWithLabels for consistency
        auto bounds = getLocalBounds();
        label.setBounds(bounds.removeFromBottom(20));
        // Adjust the bounds for the ComboBox aesthetics within the remaining space
        // Center the combobox vertically with a fixed height of 30
        comboBox.setBounds(bounds.withSizeKeepingCentre(bounds.getWidth(), 30));
    }

    void setTooltip(const juce::String& newTooltip)
    {
        juce::SettableTooltipClient::setTooltip(newTooltip);
        comboBox.setTooltip(newTooltip);
        label.setTooltip(newTooltip);
    }

    juce::ComboBox& getComboBox() { return comboBox; }
private:
    juce::ComboBox comboBox;
    juce::Label label;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> attachment;
};

// NEW: An encapsulated component for the Input/Output vertical faders.
// UPDATED: Inherit from juce::SettableTooltipClient
class VerticalFaderWithAttachment : public juce::Component, public juce::SettableTooltipClient
{
public:
    VerticalFaderWithAttachment(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramID, const juce::String& labelText)
    {
        // Configure slider for vertical movement
        slider.setSliderStyle(juce::Slider::LinearVertical);
        // Hide the text box as shown in the screenshot
        slider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);
        addAndMakeVisible(slider);

        /* FIX: Removed the manual setRange call. The SliderAttachment handles this automatically and robustly.
        // Explicitly set the range to ensure the LookAndFeel correctly identifies the 0 point for bipolar visualization
        if (auto* param = apvts.getParameter(paramID)) {
            slider.setRange(param->getNormalisableRange().start, param->getNormalisableRange().end);
        }
        */

        // Setup the attachment
        attachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(apvts, paramID, slider);

        // Configure the label
        label.setText(labelText, juce::dontSendNotification);
        label.setJustificationType(juce::Justification::centred);
        label.setFont(juce::FontOptions(14.0f));
        addAndMakeVisible(label);
    }

    void resized() override
    {
        auto bounds = getLocalBounds();
        // Label at the top
        label.setBounds(bounds.removeFromTop(20));
        slider.setBounds(bounds);
    }

    // Implement setTooltip for consistency
    void setTooltip(const juce::String& newTooltip)
    {
        juce::SettableTooltipClient::setTooltip(newTooltip);
        slider.setTooltip(newTooltip);
        label.setTooltip(newTooltip);
    }
private:
    juce::Slider slider;
    juce::Label label;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> attachment;
};
// A vertical slider component with a label (used in ChromaTape)
// UPDATED: Inherit from juce::SettableTooltipClient
class VerticalSliderWithLabel : public juce::Component, public juce::SettableTooltipClient
{
public:
    VerticalSliderWithLabel(const juce::String& labelText)
    {
        slider.setSliderStyle(juce::Slider::LinearVertical);
        slider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0);
        addAndMakeVisible(slider);

        label.setText(labelText, juce::dontSendNotification);
        label.setJustificationType(juce::Justification::centred);
        label.setFont(juce::FontOptions(14.0f));
        addAndMakeVisible(label);
    }

    void resized() override
    {
        auto bounds = getLocalBounds();
        // Label at the top, matching the screenshot (Saturation, Wow, Flutter labels)
        label.setBounds(bounds.removeFromTop(20));
        slider.setBounds(bounds);
    }

    // Public accessor for the internal slider
    juce::Slider& getSlider() {
        return slider;
    }

    // Implement setTooltip
    void setTooltip(const juce::String& newTooltip)
    {
        juce::SettableTooltipClient::setTooltip(newTooltip);
        slider.setTooltip(newTooltip);
        label.setTooltip(newTooltip);
    }
private:
    juce::Slider slider;
    juce::Label label;
};
// A text box for displaying parameter values
// UPDATED: Inherit from juce::SettableTooltipClient
class ParameterTextBox : public juce::Component, public juce::SettableTooltipClient,
    private juce::AudioProcessorValueTreeState::Listener,
    private juce::Timer
{
public:
    ParameterTextBox(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramID, const juce::String& labelText);
    ~ParameterTextBox() override;

    void paint(juce::Graphics& g) override;
    void resized() override;

    // Implement setTooltip
    void setTooltip(const juce::String& newTooltip)
    {
        juce::SettableTooltipClient::setTooltip(newTooltip);
    }
private:
    void parameterChanged(const juce::String& parameterID, float newValue) override;
    void timerCallback() override {
        repaint();
    }

    juce::AudioProcessorValueTreeState& apvts;
    juce::String paramId;
    juce::String labelText;
    juce::RangedAudioParameter* parameter = nullptr;

    CustomLookAndFeel lookAndFeel;
};

================================================================================
// File: PhysicalResonatorSlotEditor.cpp
================================================================================

/*
  ==============================================================================

    PhysicalResonatorSlotEditor.cpp
    Created: 11 Sep 2025 12:09:46pm
    Author:  agusr

  ==============================================================================
*/
#include "PhysicalResonatorSlotEditor.h"

PhysicalResonatorSlotEditor::PhysicalResonatorSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& prefix)
    : SlotEditorBase(apvts, prefix),
    physResPrefix(prefix + "PHYSRES_"),
    // Initialize Main Controls
    modelBox(apvts, physResPrefix + "MODEL", "Model"),
    tuneKnob(apvts, physResPrefix + "TUNE", "Tune"),
    structureKnob(apvts, physResPrefix + "STRUCTURE", "Structure"),
    brightnessKnob(apvts, physResPrefix + "BRIGHTNESS", "Brightness"),
    dampingKnob(apvts, physResPrefix + "DAMPING", "Damping"),
    positionKnob(apvts, physResPrefix + "POSITION", "Position"),
    mixKnob(apvts, physResPrefix + "MIX", "Mix"),
    // Initialize Excitation Engine Controls
    exciteTypeKnob(apvts, physResPrefix + "EXCITE_TYPE", "Excite Type"),
    sensitivityKnob(apvts, physResPrefix + "SENSITIVITY", "Sensitivity"),
    // Initialize Advanced Excitation
    noiseTypeBox(apvts, physResPrefix + "NOISE_TYPE", "Noise Type"),
    attackKnob(apvts, physResPrefix + "ATTACK", "Attack"),
    decayKnob(apvts, physResPrefix + "DECAY", "Decay"),
    sustainKnob(apvts, physResPrefix + "SUSTAIN", "Sustain"),
    releaseKnob(apvts, physResPrefix + "RELEASE", "Release")
{
    // Add all components
    addAndMakeVisible(modelBox);
    addAndMakeVisible(tuneKnob);
    addAndMakeVisible(structureKnob);
    addAndMakeVisible(brightnessKnob);
    addAndMakeVisible(dampingKnob);
    addAndMakeVisible(positionKnob);
    addAndMakeVisible(mixKnob);

    addAndMakeVisible(exciteTypeKnob);
    addAndMakeVisible(sensitivityKnob);
    addAndMakeVisible(noiseTypeBox);
    addAndMakeVisible(attackKnob);
    addAndMakeVisible(decayKnob);
    addAndMakeVisible(sustainKnob);
    addAndMakeVisible(releaseKnob);

    // Setup Group Components for visual separation
    addAndMakeVisible(mainGroup);
    mainGroup.setText("Resonator Core");
    // Set look and feel to use the custom one for consistent colors
    mainGroup.setLookAndFeel(&getLookAndFeel());

    addAndMakeVisible(excitationGroup);
    excitationGroup.setText("Excitation Engine");
    excitationGroup.setLookAndFeel(&getLookAndFeel());
}
void PhysicalResonatorSlotEditor::resized()
{
    // This module has many controls, so we use a structured layout with groups.

    auto bounds = getLocalBounds().reduced(5);

    // Split the layout horizontally if wide enough (e.g., > 450px), or vertically if narrow.
    bool isWide = bounds.getWidth() > 450;

    juce::Rectangle<int> mainArea, excitationArea;

    if (isWide)
    {
        // Wide layout: Resonator on the left, Excitation on the right
        mainArea = bounds.removeFromLeft(bounds.getWidth() * 0.55f).reduced(5);
        excitationArea = bounds.reduced(5);
    }
    else
    {
        // Narrow layout: Resonator on top, Excitation on the bottom
        mainArea = bounds.removeFromTop(bounds.getHeight() * 0.5f).reduced(5);
        excitationArea = bounds.reduced(5);
    }

    // Set bounds for the GroupComponents
    mainGroup.setBounds(mainArea);
    excitationGroup.setBounds(excitationArea);

    // Adjust areas for internal layout (accounting for group borders/labels)
    // Trim top for the label (approx 20px) and reduce sides for padding
    auto internalMain = mainArea.reduced(10).withTrimmedTop(20);
    auto internalExcitation = excitationArea.reduced(10).withTrimmedTop(20);


    // --- Layout Main Area (Resonator Core) ---
    juce::FlexBox mainFb;
    mainFb.flexWrap = juce::FlexBox::Wrap::wrap;
    mainFb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
    mainFb.alignContent = juce::FlexBox::AlignContent::spaceAround;

    // Define basis for 3 columns in main area
    float mainBasis = (float)internalMain.getWidth() / 3.0f;

    // Helper to define FlexItems, using the existing LayoutHelpers
    // We adapt it slightly to handle the ComboBox width preference.
    auto createFlexItem = [&](juce::Component& component, float basis) {
        // ComboBoxes might need slightly more width than standard knobs
        float minWidth = dynamic_cast<ComboBoxWithLabel*>(&component) ? 80.0f : LayoutHelpers::minKnobWidth;

        return juce::FlexItem(component)
            .withFlex(1.0f, 1.0f, basis)
            .withMinWidth(minWidth)
            .withMinHeight(LayoutHelpers::minKnobHeight);
        };

    // Row 1
    mainFb.items.add(createFlexItem(modelBox, mainBasis));
    mainFb.items.add(createFlexItem(tuneKnob, mainBasis));
    mainFb.items.add(createFlexItem(mixKnob, mainBasis));
    // Row 2+
    mainFb.items.add(createFlexItem(structureKnob, mainBasis));
    mainFb.items.add(createFlexItem(brightnessKnob, mainBasis));
    mainFb.items.add(createFlexItem(dampingKnob, mainBasis));
    mainFb.items.add(createFlexItem(positionKnob, mainBasis));

    mainFb.performLayout(internalMain);


    // --- Layout Excitation Area (Excitation Engine) ---
    juce::FlexBox excitationFb;
    excitationFb.flexWrap = juce::FlexBox::Wrap::wrap;
    excitationFb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
    excitationFb.alignContent = juce::FlexBox::AlignContent::spaceAround;

    // Define basis for 3 columns for the top row of excitation
    float exciteBasis = (float)internalExcitation.getWidth() / 3.0f;

    // Row 1
    excitationFb.items.add(createFlexItem(exciteTypeKnob, exciteBasis));
    excitationFb.items.add(createFlexItem(sensitivityKnob, exciteBasis));
    excitationFb.items.add(createFlexItem(noiseTypeBox, exciteBasis));

    // ADSR usually laid out in 4 columns
    float adsrBasis = (float)internalExcitation.getWidth() / 4.0f;
    // Row 2
    excitationFb.items.add(createFlexItem(attackKnob, adsrBasis));
    excitationFb.items.add(createFlexItem(decayKnob, adsrBasis));
    excitationFb.items.add(createFlexItem(sustainKnob, adsrBasis));
    excitationFb.items.add(createFlexItem(releaseKnob, adsrBasis));

    excitationFb.performLayout(internalExcitation);
}

================================================================================
// File: PhysicalResonatorSlotEditor.h
================================================================================

/*
  ==============================================================================

    PhysicalResonatorSlotEditor.h
    Created: 11 Sep 2025 12:09:04pm
    Author:  agusr

  ==============================================================================
*/
#pragma once

// We must include SlotEditors.h first to get the base class (SlotEditorBase) and LayoutHelpers
#include "SlotEditors.h"
#include "ParameterUIs.h"

// Inherit from SlotEditorBase
class PhysicalResonatorSlotEditor : public SlotEditorBase
{
public:
    PhysicalResonatorSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& prefix);
    void resized() override;
private:
    // Define the prefix for this module
    juce::String physResPrefix;

    // Main Controls
    ComboBoxWithLabel modelBox;
    RotaryKnobWithLabels tuneKnob, structureKnob, brightnessKnob, dampingKnob, positionKnob, mixKnob;

    // Excitation Engine Controls
    RotaryKnobWithLabels exciteTypeKnob, sensitivityKnob;

    // Advanced Excitation (ADSR + Noise)
    ComboBoxWithLabel noiseTypeBox;
    RotaryKnobWithLabels attackKnob, decayKnob, sustainKnob, releaseKnob;

    // Grouping components for visual structure
    juce::GroupComponent mainGroup, excitationGroup;
};

================================================================================
// File: SlotEditors.cpp
================================================================================

//================================================================================
// File: UI/SlotEditors.cpp
//================================================================================
#include "SlotEditors.h"

//==============================================================================
// BBDCloudSlotEditor Implementation (V2)
//==============================================================================
BBDCloudSlotEditor::BBDCloudSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& prefix)
    : SlotEditorBase(apvts, prefix),
    timeKnob(apvts, prefix + "BBDCLOUD_TIME", "Time"),
    feedbackKnob(apvts, prefix + "BBDCLOUD_FEEDBACK", "Feedback"),
    mixKnob(apvts, prefix + "BBDCLOUD_MIX", "Mix"),
    dynamicsKnob(apvts, prefix + "BBDCLOUD_DYNAMICS", "Dynamics"),
    textureKnob(apvts, prefix + "BBDCLOUD_TEXTURE", "Texture"),
    spreadKnob(apvts, prefix + "BBDCLOUD_SPREAD", "Spread"),
    ageKnob(apvts, prefix + "BBDCLOUD_AGE", "Age"),
    toneKnob(apvts, prefix + "BBDCLOUD_TONE", "Tone"),
    diffusionKnob(apvts, prefix + "BBDCLOUD_DIFFUSION", "Diffusion")
{
    addAndMakeVisible(timeKnob);
    addAndMakeVisible(feedbackKnob);
    addAndMakeVisible(mixKnob);
    addAndMakeVisible(dynamicsKnob);
    addAndMakeVisible(textureKnob);
    addAndMakeVisible(spreadKnob);
    addAndMakeVisible(ageKnob);
    addAndMakeVisible(toneKnob);
    addAndMakeVisible(diffusionKnob);
}

void BBDCloudSlotEditor::resized()
{
    auto bounds = getLocalBounds().reduced(10);
    juce::FlexBox fb;
    fb.flexWrap = juce::FlexBox::Wrap::wrap;
    fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
    fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

    float basis = (float)bounds.getWidth() / 3.0f;

    fb.items.add(LayoutHelpers::createFlexKnob(timeKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(feedbackKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(dynamicsKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(textureKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(spreadKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(ageKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(toneKnob, basis));
    fb.items.add(LayoutHelpers::createFlexKnob(diffusionKnob, basis));

    fb.performLayout(bounds);
}

================================================================================
// File: SlotEditors.h
================================================================================

﻿//================================================================================
// File: UI/SlotEditors.h
//================================================================================
#pragma once
#include <JuceHeader.h>
#include "ParameterUIs.h"
#include "../FX_Modules/FilterProcessor.h"
#include <map>

// Helper namespace for layout constants and functions
namespace LayoutHelpers {
    constexpr float minKnobWidth = 50.0f;
    constexpr float labelHeight = 20.0f;
    constexpr float minKnobHeight = minKnobWidth + labelHeight;

    inline juce::FlexItem createFlexKnob(juce::Component& component, float basis) {
        return juce::FlexItem(component)
            .withFlex(1.0f, 1.0f, basis)
            .withMinWidth(minKnobWidth)
            .withMinHeight(minKnobHeight);
    }

    inline juce::NormalisableRange<double> toDoubleRange(const juce::NormalisableRange<float>& range)
    {
        return juce::NormalisableRange<double>(
            (double)range.start,
            (double)range.end,
            [range](double start, double end, double normalized) {
                juce::ignoreUnused(start, end);
                return (double)range.convertFrom0to1((float)normalized);
            },
            [range](double start, double end, double value) {
                juce::ignoreUnused(start, end);
                return (double)range.convertTo0to1((float)value);
            },
            [range](double start, double end, double value) {
                juce::ignoreUnused(start, end);
                return (double)range.snapToLegalValue((float)value);
            }
        );
    }
}

// A simple base class for our new editors
class SlotEditorBase : public juce::Component
{
public:
    SlotEditorBase(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : apvts(apvts), paramPrefix(paramPrefix) {
    }
protected:
    juce::AudioProcessorValueTreeState& apvts;
    juce::String paramPrefix;
};

//==============================================================================
// Standard Editors
//==============================================================================

class DistortionSlotEditor : public SlotEditorBase,
    private juce::AudioProcessorValueTreeState::Listener
{
public:
    DistortionSlotEditor(juce::AudioProcessorValueTreeState& apvtsRef, const juce::String& paramPrefix)
        : SlotEditorBase(apvtsRef, paramPrefix),
        driveKnob(apvts, paramPrefix + "DISTORTION_DRIVE", "Drive"),
        levelKnob(apvts, paramPrefix + "DISTORTION_LEVEL", "Level"),
        biasKnob(apvts, paramPrefix + "DISTORTION_BIAS", "Bias"),
        characterKnob(apvts, paramPrefix + "DISTORTION_CHARACTER", "Character")
    {
        addAndMakeVisible(driveKnob);
        addAndMakeVisible(levelKnob);
        addAndMakeVisible(biasKnob);
        addAndMakeVisible(characterKnob);

        typeBox.addItemList(apvts.getParameter(paramPrefix + "DISTORTION_TYPE")->getAllValueStrings(), 1);
        addAndMakeVisible(typeBox);
        typeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramPrefix + "DISTORTION_TYPE", typeBox);

        apvts.addParameterListener(paramPrefix + "DISTORTION_TYPE", this);
        updateVisibilities();
    }

    ~DistortionSlotEditor() override
    {
        apvts.removeParameterListener(paramPrefix + "DISTORTION_TYPE", this);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        typeBox.setBounds(bounds.removeFromTop(30).reduced(5, 0));

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 2.0f;
        fb.items.add(LayoutHelpers::createFlexKnob(driveKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(levelKnob, basis));

        if (biasKnob.isVisible())
            fb.items.add(LayoutHelpers::createFlexKnob(biasKnob, basis));
        if (characterKnob.isVisible())
            fb.items.add(LayoutHelpers::createFlexKnob(characterKnob, basis));

        fb.performLayout(bounds);
    }
private:
    void parameterChanged(const juce::String&, float) override { updateVisibilities(); }

    void updateVisibilities()
    {
        auto type = static_cast<int>(apvts.getRawParameterValue(paramPrefix + "DISTORTION_TYPE")->load());
        biasKnob.setVisible(type == 0);
        characterKnob.setVisible(type == 1 || type == 2);
        if (getWidth() > 0 && getHeight() > 0)
            resized();
    }

    RotaryKnobWithLabels driveKnob, levelKnob, biasKnob, characterKnob;
    juce::ComboBox typeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> typeAttachment;
};

class FilterSlotEditor : public SlotEditorBase,
    private juce::AudioProcessorValueTreeState::Listener
{
public:
    FilterSlotEditor(juce::AudioProcessorValueTreeState& apvtsRef, const juce::String& paramPrefix)
        : SlotEditorBase(apvtsRef, paramPrefix),
        cutoffKnob(apvts, paramPrefix + "FILTER_CUTOFF", "Cutoff"),
        resonanceKnob(apvts, paramPrefix + "FILTER_RESONANCE", "Resonance"),
        driveKnob(apvts, paramPrefix + "FILTER_DRIVE", "Drive")
    {
        addAndMakeVisible(cutoffKnob);
        addAndMakeVisible(resonanceKnob);
        addAndMakeVisible(driveKnob);

        profileBox.addItemList(apvts.getParameter(paramPrefix + "FILTER_PROFILE")->getAllValueStrings(), 1);
        addAndMakeVisible(profileBox);
        profileAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramPrefix + "FILTER_PROFILE", profileBox);

        typeBox.addItemList(apvts.getParameter(paramPrefix + "FILTER_TYPE")->getAllValueStrings(), 1);
        addAndMakeVisible(typeBox);
        typeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramPrefix + "FILTER_TYPE", typeBox);

        apvts.addParameterListener(paramPrefix + "FILTER_PROFILE", this);
        updateVisibilities();
    }

    ~FilterSlotEditor() override
    {
        apvts.removeParameterListener(paramPrefix + "FILTER_PROFILE", this);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        auto topStrip = bounds.removeFromTop(30);

        if (typeBox.isVisible())
        {
            profileBox.setBounds(topStrip.removeFromLeft(topStrip.getWidth() / 2).reduced(5, 0));
            typeBox.setBounds(topStrip.reduced(5, 0));
        }
        else
        {
            profileBox.setBounds(topStrip.reduced(5, 0));
        }

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;
        int visibleKnobs = 2 + (driveKnob.isVisible() ? 1 : 0);
        float basis = (float)bounds.getWidth() / (float)visibleKnobs;

        fb.items.add(LayoutHelpers::createFlexKnob(cutoffKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(resonanceKnob, basis));
        if (driveKnob.isVisible())
            fb.items.add(LayoutHelpers::createFlexKnob(driveKnob, basis));

        fb.performLayout(bounds);
    }
private:
    void parameterChanged(const juce::String&, float) override { updateVisibilities(); }

    void updateVisibilities()
    {
        auto* profileParam = apvts.getRawParameterValue(paramPrefix + "FILTER_PROFILE");
        auto profile = static_cast<FilterProcessor::Profile>(static_cast<int>(profileParam->load()));

        typeBox.setVisible(profile == FilterProcessor::svfProfile);
        driveKnob.setVisible(profile == FilterProcessor::transistorLadder || profile == FilterProcessor::diodeLadder);
        if (getWidth() > 0 && getHeight() > 0)
            resized();
    }

    RotaryKnobWithLabels cutoffKnob, resonanceKnob, driveKnob;
    juce::ComboBox profileBox, typeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> profileAttachment, typeAttachment;
};

class AdvancedDelaySlotEditor : public SlotEditorBase
{
public:
    AdvancedDelaySlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        advDelayPrefix(paramPrefix + "ADVDELAY_"),
        timeKnob(apvts, advDelayPrefix + "TIME", "Time"),
        feedbackKnob(apvts, advDelayPrefix + "FEEDBACK", "Feedback"),
        mixKnob(apvts, advDelayPrefix + "MIX", "Mix"),
        colorKnob(apvts, advDelayPrefix + "COLOR", "Color"),
        wowKnob(apvts, advDelayPrefix + "WOW", "Wow"),
        flutterKnob(apvts, advDelayPrefix + "FLUTTER", "Flutter"),
        ageKnob(apvts, advDelayPrefix + "AGE", "Age")
    {
        addAndMakeVisible(timeKnob);
        addAndMakeVisible(feedbackKnob);
        addAndMakeVisible(mixKnob);
        addAndMakeVisible(colorKnob);
        addAndMakeVisible(wowKnob);
        addAndMakeVisible(flutterKnob);
        addAndMakeVisible(ageKnob);

        if (apvts.getParameter(advDelayPrefix + "MODE"))
        {
            modeBox.addItemList(apvts.getParameter(advDelayPrefix + "MODE")->getAllValueStrings(), 1);
            addAndMakeVisible(modeBox);
            modeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, advDelayPrefix + "MODE", modeBox);
        }
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        if (modeBox.isVisible())
            modeBox.setBounds(bounds.removeFromTop(30).reduced(5, 0));

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 3.0f;
        if (basis < LayoutHelpers::minKnobWidth && bounds.getWidth() > LayoutHelpers::minKnobWidth * 2)
            basis = (float)bounds.getWidth() / 2.0f;
        fb.items.add(LayoutHelpers::createFlexKnob(timeKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(feedbackKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(colorKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(wowKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(flutterKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(ageKnob, basis));

        fb.performLayout(bounds);
    }
private:
    juce::String advDelayPrefix;
    RotaryKnobWithLabels timeKnob, feedbackKnob, mixKnob, colorKnob, wowKnob, flutterKnob, ageKnob;
    juce::ComboBox modeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> modeAttachment;
};

class ModulationSlotEditor : public SlotEditorBase
{
public:
    ModulationSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        rateKnob(apvts, paramPrefix + "MODULATION_RATE", "Rate"),
        depthKnob(apvts, paramPrefix + "MODULATION_DEPTH", "Depth"),
        feedbackKnob(apvts, paramPrefix + "MODULATION_FEEDBACK", "Feedback"),
        mixKnob(apvts, paramPrefix + "MODULATION_MIX", "Mix")
    {
        addAndMakeVisible(rateKnob);
        addAndMakeVisible(depthKnob);
        addAndMakeVisible(feedbackKnob);
        addAndMakeVisible(mixKnob);

        modeBox.addItemList(apvts.getParameter(paramPrefix + "MODULATION_MODE")->getAllValueStrings(), 1);
        addAndMakeVisible(modeBox);
        modeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramPrefix + "MODULATION_MODE", modeBox);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        modeBox.setBounds(bounds.removeFromTop(30).reduced(5, 0));

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 2.0f;
        fb.items.add(LayoutHelpers::createFlexKnob(rateKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(depthKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(feedbackKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));

        fb.performLayout(bounds);
    }
private:
    RotaryKnobWithLabels rateKnob, depthKnob, feedbackKnob, mixKnob;
    juce::ComboBox modeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> modeAttachment;
};

class ReverbSlotEditor : public SlotEditorBase
{
public:
    ReverbSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        roomSizeKnob(apvts, paramPrefix + "REVERB_ROOM_SIZE", "Room Size"),
        dampingKnob(apvts, paramPrefix + "REVERB_DAMPING", "Damping"),
        mixKnob(apvts, paramPrefix + "REVERB_MIX", "Mix"),
        widthKnob(apvts, paramPrefix + "REVERB_WIDTH", "Width")
    {
        addAndMakeVisible(roomSizeKnob);
        addAndMakeVisible(dampingKnob);
        addAndMakeVisible(mixKnob);
        addAndMakeVisible(widthKnob);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 2.0f;

        fb.items.add(LayoutHelpers::createFlexKnob(roomSizeKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(dampingKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(widthKnob, basis));

        fb.performLayout(bounds);
    }
private:
    RotaryKnobWithLabels roomSizeKnob, dampingKnob, mixKnob, widthKnob;
};

class AdvancedCompressorSlotEditor : public SlotEditorBase
{
public:
    AdvancedCompressorSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        advCompPrefix(paramPrefix + "ADVCOMP_"),
        thresholdKnob(apvts, advCompPrefix + "THRESHOLD", "Threshold"),
        ratioKnob(apvts, advCompPrefix + "RATIO", "Ratio"),
        attackKnob(apvts, advCompPrefix + "ATTACK", "Attack"),
        releaseKnob(apvts, advCompPrefix + "RELEASE", "Release"),
        makeupKnob(apvts, advCompPrefix + "MAKEUP", "Makeup")
    {
        addAndMakeVisible(thresholdKnob);
        addAndMakeVisible(ratioKnob);
        addAndMakeVisible(attackKnob);
        addAndMakeVisible(releaseKnob);
        addAndMakeVisible(makeupKnob);

        if (apvts.getParameter(advCompPrefix + "TOPOLOGY") && apvts.getParameter(advCompPrefix + "DETECTOR"))
        {
            topologyBox.addItemList(apvts.getParameter(advCompPrefix + "TOPOLOGY")->getAllValueStrings(), 1);
            addAndMakeVisible(topologyBox);
            topologyAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, advCompPrefix + "TOPOLOGY", topologyBox);

            detectorBox.addItemList(apvts.getParameter(advCompPrefix + "DETECTOR")->getAllValueStrings(), 1);
            addAndMakeVisible(detectorBox);
            detectorAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, advCompPrefix + "DETECTOR", detectorBox);
        }
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        auto topStrip = bounds.removeFromTop(30);

        if (topologyBox.isVisible() && detectorBox.isVisible())
        {
            topologyBox.setBounds(topStrip.removeFromLeft(topStrip.getWidth() / 2).reduced(5, 0));
            detectorBox.setBounds(topStrip.reduced(5, 0));
        }

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 3.0f;
        if (basis < LayoutHelpers::minKnobWidth && bounds.getWidth() > LayoutHelpers::minKnobWidth * 2)
            basis = (float)bounds.getWidth() / 2.0f;
        fb.items.add(LayoutHelpers::createFlexKnob(thresholdKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(ratioKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(attackKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(releaseKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(makeupKnob, basis));

        fb.performLayout(bounds);
    }
private:
    juce::String advCompPrefix;
    RotaryKnobWithLabels thresholdKnob, ratioKnob, attackKnob, releaseKnob, makeupKnob;
    juce::ComboBox topologyBox, detectorBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> topologyAttachment, detectorAttachment;
};

class ChromaTapeSlotEditor : public SlotEditorBase,
    private juce::Timer
{
public:
    ChromaTapeSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        ctPrefix(paramPrefix + "CT_"),
        lowMidCrossKnob(apvts, ctPrefix + "LOWMID_CROSS", "L/M Blend"),
        midHighCrossKnob(apvts, ctPrefix + "MIDHIGH_CROSS", "M/H Blend"),
        saturationSlider("Saturation"),
        wowSlider("Wow"),
        flutterSlider("Flutter")
    {
        addAndMakeVisible(lowMidCrossKnob);
        addAndMakeVisible(midHighCrossKnob);
        addAndMakeVisible(saturationSlider);
        addAndMakeVisible(wowSlider);
        addAndMakeVisible(flutterSlider);

        const std::array<juce::String, 3> bands = { "LOW", "MID", "HIGH" };
        for (int i = 0; i < 3; ++i)
        {
            sliderParams[&saturationSlider.getSlider()][i] = apvts.getParameter(ctPrefix + bands[i] + "_SATURATION");
            sliderParams[&wowSlider.getSlider()][i] = apvts.getParameter(ctPrefix + bands[i] + "_WOW");
            sliderParams[&flutterSlider.getSlider()][i] = apvts.getParameter(ctPrefix + bands[i] + "_FLUTTER");
        }

        setupSliders();
        setupButtons();
        lowButton.setToggleState(true, juce::dontSendNotification);
        updateSliderTargets();
        initializeAnimations();
        startTimerHz(60);
    }

    ~ChromaTapeSlotEditor() override
    {
        stopTimer();
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        int crossoverHeight = 100;
        int buttonHeight = 40;
        auto crossoverArea = bounds.removeFromTop(crossoverHeight);
        auto buttonArea = bounds.removeFromBottom(buttonHeight);
        auto sliderArea = bounds;

        juce::FlexBox crossoverFb;
        crossoverFb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        crossoverFb.items.add(LayoutHelpers::createFlexKnob(lowMidCrossKnob, 100.0f));
        crossoverFb.items.add(LayoutHelpers::createFlexKnob(midHighCrossKnob, 100.0f));
        crossoverFb.performLayout(crossoverArea);

        juce::FlexBox sliderFb;
        sliderFb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        sliderFb.alignItems = juce::FlexBox::AlignItems::stretch;

        auto createSliderItem = [&](VerticalSliderWithLabel& slider) {
            return juce::FlexItem(slider).withFlex(1.0f).withMinWidth(50.0f).withMargin(5);
            };

        sliderFb.items.add(createSliderItem(saturationSlider));
        sliderFb.items.add(createSliderItem(wowSlider));
        sliderFb.items.add(createSliderItem(flutterSlider));
        sliderFb.performLayout(sliderArea);

        int btnHeight = 30;
        lowButton.setBounds(buttonArea.withSize(saturationSlider.getWidth(), btnHeight)
            .withCentre(juce::Point<int>(saturationSlider.getBounds().getCentreX(), buttonArea.getCentreY())));
        midButton.setBounds(buttonArea.withSize(wowSlider.getWidth(), btnHeight)
            .withCentre(juce::Point<int>(wowSlider.getBounds().getCentreX(), buttonArea.getCentreY())));
        highButton.setBounds(buttonArea.withSize(flutterSlider.getWidth(), btnHeight)
            .withCentre(juce::Point<int>(flutterSlider.getBounds().getCentreX(), buttonArea.getCentreY())));
    }
private:
    void timerCallback() override
    {
        updateSliderTargets();
        const float animationSpeed = 0.25f;

        for (auto& pair : sliderAnimations)
        {
            juce::Slider* slider = pair.first;
            AnimationState& state = pair.second;

            if (std::abs(state.target - state.current) > 1e-4)
            {
                state.current += (state.target - state.current) * animationSpeed;
                slider->setValue(slider->proportionOfLengthToValue(state.current), juce::dontSendNotification);
            }
            else if (state.current != state.target)
            {
                state.current = state.target;
                slider->setValue(slider->proportionOfLengthToValue(state.current), juce::dontSendNotification);
            }
        }
    }

    void bandButtonClicked(int bandIndex)
    {
        if (currentBand == bandIndex) return;
        currentBand = bandIndex;
    }

    void sliderValueChanged(juce::Slider* slider)
    {
        auto* param = sliderParams[slider][currentBand];
        if (param)
        {
            float normalizedValue = (float)slider->valueToProportionOfLength(slider->getValue());
            if (std::abs(param->getValue() - normalizedValue) > 1e-6)
            {
                param->setValueNotifyingHost(normalizedValue);
            }

            sliderAnimations[slider].current = normalizedValue;
            sliderAnimations[slider].target = normalizedValue;
        }
    }

    void updateSliderTargets()
    {
        for (auto& pair : sliderParams)
        {
            juce::Slider* slider = pair.first;
            auto* param = pair.second[currentBand];
            if (param)
            {
                slider->setNormalisableRange(LayoutHelpers::toDoubleRange(param->getNormalisableRange()));
                sliderAnimations[slider].target = param->getValue();
            }
        }
    }

    void setupSliders()
    {
        auto configureSlider = [&](VerticalSliderWithLabel& vSlider)
            {
                juce::Slider& slider = vSlider.getSlider();
                slider.onValueChange = [this, &slider] { sliderValueChanged(&slider); };
            };

        configureSlider(saturationSlider);
        configureSlider(wowSlider);
        configureSlider(flutterSlider);
    }

    void setupButtons()
    {
        addAndMakeVisible(lowButton);
        addAndMakeVisible(midButton);
        addAndMakeVisible(highButton);
        const int radioGroup = 1001;
        lowButton.setRadioGroupId(radioGroup);
        midButton.setRadioGroupId(radioGroup);
        highButton.setRadioGroupId(radioGroup);
        lowButton.setClickingTogglesState(true);
        midButton.setClickingTogglesState(true);
        highButton.setClickingTogglesState(true);

        auto* laf = &getLookAndFeel();
        lowButton.setLookAndFeel(laf);
        midButton.setLookAndFeel(laf);
        highButton.setLookAndFeel(laf);
        lowButton.onClick = [this] { bandButtonClicked(0); };
        midButton.onClick = [this] { bandButtonClicked(1); };
        highButton.onClick = [this] { bandButtonClicked(2); };
    }

    void initializeAnimations()
    {
        for (auto& pair : sliderParams)
        {
            juce::Slider* slider = pair.first;
            auto* param = pair.second[0];
            if (param)
            {
                slider->setNormalisableRange(LayoutHelpers::toDoubleRange(param->getNormalisableRange()));
            }
        }

        updateSliderTargets();
        for (auto& pair : sliderAnimations)
        {
            pair.second.current = pair.second.target;
            juce::Slider* slider = pair.first;
            slider->setValue(slider->proportionOfLengthToValue(pair.second.current), juce::dontSendNotification);
        }
    }

    juce::String ctPrefix;
    int currentBand = 0;
    RotaryKnobWithLabels lowMidCrossKnob, midHighCrossKnob;
    VerticalSliderWithLabel saturationSlider, wowSlider, flutterSlider;
    juce::TextButton lowButton{ "Low" }, midButton{ "Mid" }, highButton{ "High" };

    struct AnimationState { float current = 0.0f; float target = 0.0f; };
    std::map<juce::Slider*, AnimationState> sliderAnimations;
    std::map<juce::Slider*, std::array<juce::RangedAudioParameter*, 3>> sliderParams;
};

class BBDCloudSlotEditor : public SlotEditorBase
{
public:
    BBDCloudSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& prefix);
    void resized() override;
private:
    RotaryKnobWithLabels timeKnob, feedbackKnob, mixKnob;
    RotaryKnobWithLabels dynamicsKnob, textureKnob, spreadKnob;
    RotaryKnobWithLabels ageKnob, toneKnob, diffusionKnob;
};

class FractureTubeSlotEditor : public SlotEditorBase
{
public:
    FractureTubeSlotEditor(juce::AudioProcessorValueTreeState& apvtsRef, const juce::String& paramPrefix)
        : SlotEditorBase(apvtsRef, paramPrefix),
        driveKnob(apvts, paramPrefix + "FRACTURE_DRIVE", "Drive"),
        biasKnob(apvts, paramPrefix + "FRACTURE_BIAS", "Bias"),
        sensitivityKnob(apvts, paramPrefix + "FRACTURE_SENSITIVITY", "Sensitivity"),
        textureMixKnob(apvts, paramPrefix + "FRACTURE_TEXTURE_MIX", "Texture Mix"),
        densityKnob(apvts, paramPrefix + "FRACTURE_DENSITY", "Density"),
        pitchKnob(apvts, paramPrefix + "FRACTURE_PITCH", "Pitch")
    {
        addAndMakeVisible(driveKnob);
        addAndMakeVisible(biasKnob);
        addAndMakeVisible(sensitivityKnob);
        addAndMakeVisible(textureMixKnob);
        addAndMakeVisible(densityKnob);
        addAndMakeVisible(pitchKnob);

        addAndMakeVisible(freezeButton);
        freezeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ButtonAttachment>(apvts, paramPrefix + "FRACTURE_FREEZE", freezeButton);
        freezeButton.setButtonText("Freeze");
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        auto bottomStrip = bounds.removeFromBottom(40);

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 3.0f;

        fb.items.add(LayoutHelpers::createFlexKnob(driveKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(biasKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(sensitivityKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(densityKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(pitchKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(textureMixKnob, basis));

        fb.performLayout(bounds);

        freezeButton.setBounds(bottomStrip.withSizeKeepingCentre(80, 30));
    }
private:
    RotaryKnobWithLabels driveKnob, biasKnob, sensitivityKnob, textureMixKnob, densityKnob, pitchKnob;
    juce::ToggleButton freezeButton;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ButtonAttachment> freezeAttachment;
};

class MorphoCompSlotEditor : public SlotEditorBase
{
public:
    MorphoCompSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        amountKnob(apvts, paramPrefix + "MORPHO_AMOUNT", "Amount"),
        responseKnob(apvts, paramPrefix + "MORPHO_RESPONSE", "Response"),
        mixKnob(apvts, paramPrefix + "MORPHO_MIX", "Mix"),
        morphXKnob(apvts, paramPrefix + "MORPHO_X", "Morph X"),
        morphYKnob(apvts, paramPrefix + "MORPHO_Y", "Morph Y")

    {
        addAndMakeVisible(amountKnob);
        addAndMakeVisible(responseKnob);
        addAndMakeVisible(mixKnob);
        addAndMakeVisible(morphXKnob);
        addAndMakeVisible(morphYKnob);

        modeBox.addItemList(apvts.getParameter(paramPrefix + "MORPHO_MODE")->getAllValueStrings(), 1);
        addAndMakeVisible(modeBox);
        modeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, paramPrefix + "MORPHO_MODE", modeBox);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        modeBox.setBounds(bounds.removeFromTop(30).reduced(5, 0));


        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;
        float basis = (float)bounds.getWidth() / 3.0f;
        fb.items.add(LayoutHelpers::createFlexKnob(amountKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(responseKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));

        fb.items.add(LayoutHelpers::createFlexKnob(morphXKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(morphYKnob, basis));

        fb.performLayout(bounds);
    }
private:
    RotaryKnobWithLabels amountKnob, responseKnob, mixKnob, morphXKnob, morphYKnob;
    juce::ComboBox modeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> modeAttachment;
};

class PlaceholderSlotEditor : public SlotEditorBase
{
public:
    PlaceholderSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix, const juce::String& message)
        : SlotEditorBase(apvts, paramPrefix)
    {
        label.setText(message + "\n(DSP Pending)", juce::dontSendNotification);
        label.setJustificationType(juce::Justification::centred);
        addAndMakeVisible(label);
    }
    void resized() override { label.setBounds(getLocalBounds()); }
private:
    juce::Label label;
};

class PhysicalResonatorSlotEditor : public SlotEditorBase
{
public:
    PhysicalResonatorSlotEditor(juce::AudioProcessorValueTreeState& apvts, const juce::String& paramPrefix)
        : SlotEditorBase(apvts, paramPrefix),
        physResPrefix(paramPrefix + "PHYSRES_"),
        tuneKnob(apvts, physResPrefix + "TUNE", "Tune"),
        decayKnob(apvts, physResPrefix + "DECAY", "Decay"),
        materialKnob(apvts, physResPrefix + "MATERIAL", "Material"),
        harmonicityKnob(apvts, physResPrefix + "HARMONICITY", "Harmonicity"),
        adaptationKnob(apvts, physResPrefix + "ADAPTATION", "Adaptation"),
        sensitivityKnob(apvts, physResPrefix + "SENSITIVITY", "Sensitivity"),
        mixKnob(apvts, physResPrefix + "MIX", "Mix")
    {
        addAndMakeVisible(tuneKnob);
        addAndMakeVisible(decayKnob);
        addAndMakeVisible(materialKnob);
        addAndMakeVisible(harmonicityKnob);
        addAndMakeVisible(adaptationKnob);
        addAndMakeVisible(sensitivityKnob);
        addAndMakeVisible(mixKnob);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);
        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 3.0f; // Aim for 3 knobs per row
        if (basis < LayoutHelpers::minKnobWidth && bounds.getWidth() > LayoutHelpers::minKnobWidth * 2)
            basis = (float)bounds.getWidth() / 2.0f; // Fallback to 2 if too small

        fb.items.add(LayoutHelpers::createFlexKnob(tuneKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(decayKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(materialKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(harmonicityKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(adaptationKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(sensitivityKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(mixKnob, basis));

        fb.performLayout(bounds);
    }

private:
    juce::String physResPrefix;
    RotaryKnobWithLabels tuneKnob, decayKnob, materialKnob, harmonicityKnob;
    RotaryKnobWithLabels adaptationKnob, sensitivityKnob, mixKnob;
};

//==============================================================================
// NEW: Spectral Animator Editor
// FIX: Ensure this definition is complete (it was truncated in the input)
//==============================================================================
class SpectralAnimatorSlotEditor : public SlotEditorBase,
    private juce::AudioProcessorValueTreeState::Listener
{
public:
    SpectralAnimatorSlotEditor(juce::AudioProcessorValueTreeState& apvtsRef, const juce::String& paramPrefix)
        : SlotEditorBase(apvtsRef, paramPrefix),
        specAnimPrefix(paramPrefix + "SPECANIM_"),
        pitchKnob(apvts, specAnimPrefix + "PITCH", "Pitch"),
        formantXKnob(apvts, specAnimPrefix + "FORMANT_X", "Formant X"),
        formantYKnob(apvts, specAnimPrefix + "FORMANT_Y", "Formant Y"),
        morphKnob(apvts, specAnimPrefix + "MORPH", "Morph"),
        transientKnob(apvts, specAnimPrefix + "TRANSIENT_PRESERVE", "Transients")
    {
        // FIX: Complete the truncated constructor
        addAndMakeVisible(pitchKnob);
        addAndMakeVisible(formantXKnob);
        addAndMakeVisible(formantYKnob);
        addAndMakeVisible(morphKnob);
        addAndMakeVisible(transientKnob);

        // Setup Mode ComboBox
        if (auto* modeParam = apvts.getParameter(specAnimPrefix + "MODE"))
        {
            modeBox.addItemList(modeParam->getAllValueStrings(), 1);
            addAndMakeVisible(modeBox);
            modeAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment>(apvts, specAnimPrefix + "MODE", modeBox);
        }

        // Register listener for mode changes
        apvts.addParameterListener(specAnimPrefix + "MODE", this);
        updateVisibilities(); // Initial visibility setup
    }

    // FIX: Add missing methods (Destructor, resized, etc.)
    ~SpectralAnimatorSlotEditor() override
    {
        apvts.removeParameterListener(specAnimPrefix + "MODE", this);
    }

    void resized() override
    {
        auto bounds = getLocalBounds().reduced(10);

        if (modeBox.isVisible())
            modeBox.setBounds(bounds.removeFromTop(30).reduced(5, 0));

        juce::FlexBox fb;
        fb.flexWrap = juce::FlexBox::Wrap::wrap;
        fb.justifyContent = juce::FlexBox::JustifyContent::spaceAround;
        fb.alignContent = juce::FlexBox::AlignContent::spaceAround;

        float basis = (float)bounds.getWidth() / 3.0f;

        if (pitchKnob.isVisible()) fb.items.add(LayoutHelpers::createFlexKnob(pitchKnob, basis));
        if (formantXKnob.isVisible()) fb.items.add(LayoutHelpers::createFlexKnob(formantXKnob, basis));
        if (formantYKnob.isVisible()) fb.items.add(LayoutHelpers::createFlexKnob(formantYKnob, basis));

        fb.items.add(LayoutHelpers::createFlexKnob(morphKnob, basis));
        fb.items.add(LayoutHelpers::createFlexKnob(transientKnob, basis));

        fb.performLayout(bounds);
    }
private:
    void parameterChanged(const juce::String& parameterID, float newValue) override
    {
        if (parameterID == specAnimPrefix + "MODE")
        {
            updateVisibilities();
        }
        juce::ignoreUnused(newValue);
    }

    void updateVisibilities()
    {
        if (auto* modeParam = apvts.getRawParameterValue(specAnimPrefix + "MODE"))
        {
            auto mode = static_cast<int>(modeParam->load());
            pitchKnob.setVisible(mode == 0); // Pitch Mode
            formantXKnob.setVisible(mode == 1); // Formant Mode
            formantYKnob.setVisible(mode == 1);
        }

        if (getWidth() > 0 && getHeight() > 0)
            resized();
    }

    juce::String specAnimPrefix;
    RotaryKnobWithLabels pitchKnob, formantXKnob, formantYKnob, morphKnob, transientKnob;
    juce::ComboBox modeBox;
    std::unique_ptr<juce::AudioProcessorValueTreeState::ComboBoxAttachment> modeAttachment;
};

